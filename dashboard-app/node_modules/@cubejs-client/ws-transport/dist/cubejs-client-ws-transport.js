'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _objectSpread2 = _interopDefault(require('@babel/runtime/helpers/objectSpread'));
var _objectWithoutProperties = _interopDefault(require('@babel/runtime/helpers/objectWithoutProperties'));
require('core-js/modules/es6.array.filter');
require('core-js/modules/es6.array.find');
require('core-js/modules/es6.promise');
require('core-js/modules/web.dom.iterable');
require('core-js/modules/es6.array.iterator');
require('core-js/modules/es6.object.to-string');
require('core-js/modules/es6.object.keys');
require('core-js/modules/es6.array.for-each');
var _regeneratorRuntime = _interopDefault(require('@babel/runtime/regenerator'));
require('regenerator-runtime/runtime');
var _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var _classCallCheck = _interopDefault(require('@babel/runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var WebSocket = _interopDefault(require('isomorphic-ws'));

var WebSocketTransportResult =
/*#__PURE__*/
function () {
  function WebSocketTransportResult(_ref) {
    var status = _ref.status,
        message = _ref.message;

    _classCallCheck(this, WebSocketTransportResult);

    this.status = status;
    this.result = message;
  }

  _createClass(WebSocketTransportResult, [{
    key: "json",
    value: function () {
      var _json = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.result);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function json() {
        return _json.apply(this, arguments);
      }

      return json;
    }()
  }]);

  return WebSocketTransportResult;
}();

var WebSocketTransport =
/*#__PURE__*/
function () {
  function WebSocketTransport(_ref2) {
    var authorization = _ref2.authorization,
        apiUrl = _ref2.apiUrl,
        hearBeatInterval = _ref2.hearBeatInterval;

    _classCallCheck(this, WebSocketTransport);

    this.authorization = authorization;
    this.apiUrl = apiUrl;
    this.messageCounter = 1;
    this.messageIdToSubscription = {};
    this.messageQueue = [];
    this.hearBeatInterval = hearBeatInterval || 60;
  }

  _createClass(WebSocketTransport, [{
    key: "initSocket",
    value: function initSocket() {
      var _this = this;

      if (this.ws) {
        return this.ws.initPromise;
      }

      var ws = new WebSocket(this.apiUrl);
      ws.messageIdSent = {};

      ws.sendMessage = function (message) {
        if (!message.messageId || message.messageId && !ws.messageIdSent[message.messageId]) {
          ws.send(JSON.stringify(message));
          ws.messageIdSent[message.messageId] = true;
        }
      };

      ws.sendQueue = function () {
        _this.messageQueue.forEach(function (message) {
          return ws.sendMessage(message);
        });

        _this.messageQueue = [];
      };

      ws.reconcile = function () {
        if (new Date().getTime() - ws.lastMessageTimestamp.getTime() > 4 * _this.hearBeatInterval * 1000) {
          ws.close();
        } else {
          Object.keys(_this.messageIdToSubscription).forEach(function (messageId) {
            ws.sendMessage(_this.messageIdToSubscription[messageId].message);
          });
        }
      };

      ws.lastMessageTimestamp = new Date();
      ws.initPromise = new Promise(function (resolve) {
        ws.onopen = function () {
          ws.sendMessage({
            authorization: _this.authorization
          });
        };

        ws.onmessage = function (message) {
          ws.lastMessageTimestamp = new Date();
          message = JSON.parse(message.data);

          if (message.handshake) {
            ws.reconcile();
            ws.reconcileTimer = setInterval(function () {
              ws.messageIdSent = {};
              ws.reconcile();
            }, _this.hearBeatInterval * 1000);
            resolve();
          }

          if (_this.messageIdToSubscription[message.messageId]) {
            _this.messageIdToSubscription[message.messageId].callback(new WebSocketTransportResult(message));
          }

          ws.sendQueue();
        };

        ws.onclose = function () {
          if (ws && ws.readyState !== WebSocket.CLOSED && ws.readyState !== WebSocket.CLOSING) {
            ws.close();
          }

          if (ws.reconcileTimer) {
            clearInterval(ws.reconcileTimer);
            ws.reconcileTimer = null;
          }

          if (_this.ws === ws) {
            _this.ws = null;

            if (Object.keys(_this.messageIdToSubscription).length) {
              _this.initSocket();
            }
          }
        };

        ws.onerror = ws.onclose;
      });
      this.ws = ws;
      return this.ws.initPromise;
    }
  }, {
    key: "sendMessage",
    value: function sendMessage(message) {
      var _this2 = this;

      if (message.unsubscribe && this.messageQueue.find(function (m) {
        return m.messageId === message.unsubscribe;
      })) {
        this.messageQueue = this.messageQueue.filter(function (m) {
          return m.messageId !== message.unsubscribe;
        });
      } else {
        this.messageQueue.push(message);
      }

      setTimeout(
      /*#__PURE__*/
      _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this2.initSocket();

              case 2:
                _this2.ws.sendQueue();

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })), 100);
    }
  }, {
    key: "request",
    value: function request(method, _ref4) {
      var baseRequestId = _ref4.baseRequestId,
          params = _objectWithoutProperties(_ref4, ["baseRequestId"]);

      var message = {
        messageId: this.messageCounter++,
        method: method,
        params: params
      };
      var pendingResults = [];
      var nextMessage = null;

      var runNextMessage = function runNextMessage() {
        if (nextMessage) {
          nextMessage(pendingResults.pop());
          nextMessage = null;
        }
      };

      this.messageIdToSubscription[message.messageId] = {
        message: message,
        callback: function callback(result) {
          pendingResults.push(result);
          runNextMessage();
        }
      };
      var transport = this;
      var spanCounter = 1;
      return {
        subscribe: function subscribe(callback) {
          var _this3 = this;

          return _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee3() {
            var result;
            return _regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    transport.sendMessage(_objectSpread2({
                      requestId: baseRequestId && "".concat(baseRequestId, "-span-").concat(spanCounter++)
                    }, message));
                    _context3.next = 3;
                    return new Promise(function (resolve) {
                      nextMessage = resolve;

                      if (pendingResults.length) {
                        runNextMessage();
                      }
                    });

                  case 3:
                    result = _context3.sent;
                    return _context3.abrupt("return", callback(result, function () {
                      return _this3.subscribe(callback);
                    }));

                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }))();
        },
        unsubscribe: function unsubscribe() {
          return _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee4() {
            return _regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    transport.sendMessage({
                      unsubscribe: message.messageId
                    });
                    delete transport.messageIdToSubscription[message.messageId];

                  case 2:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }))();
        }
      };
    }
  }, {
    key: "authorization",
    set: function set(token) {
      this.token = token;

      if (this.ws) {
        this.ws.close();
      }
    },
    get: function get() {
      return this.token;
    }
  }]);

  return WebSocketTransport;
}();

module.exports = WebSocketTransport;
